import numpy as np
import scipy.ndimage as nd
#from silx.image import sift
import timeit
import sys, os
import matplotlib.pyplot as plt



def crosscorrelation_align(imagestack):
    
# run over all including reference to apply the forcing evenly, repeated runs may continue to shift the image!

    reference = np.copy(imagestack[:,:,0])
    for i in range(imagestack.shape[2]):
        print 'aligning 0 with %s' %i

        (imagestack[:,:,i], ishift) = single_correlation_align(reference, imagestack[:,:,i])
        shift.append(ishift) 

    return imagestack, shift

def forcedcrosscorrelation_align(imagestack, alignment = (0,0)):
    'forms the correlation between imagestack[0] and all others. The shift is center of refernce - max of the crosscorrelation. Aligns imagestack to imagestack[:,:,0].\n Applies optional linear potential from max(alingimagestack[:,:,0]) to min(imagestack[:,:,0]) in direction alignment (see mask_align). \n tackes 3d array (X, N, M) and alligns all in X \nreturn (imagestack, shift).\nAs the image is forced towards the direction given in alignment, repeated runs may continue to shift the image! '
    shift = []

#    setup the potential to force the alignment in a certain direction
    maxforce = imagestack[:,:,0].max()
    minforce = imagestack[:,:,0].min() 
    xstepforce = (maxforce + minforce) / len(imagestack[:,0,0])
    ystepforce = (maxforce + minforce) / len(imagestack[0,:,0])

    print 'alignment = '
    print alignment
    if alignment[0]:
        x = np.atleast_2d(np.arange(minforce, maxforce, xstepforce)).T        
        x = x[::-alignment[0]]
    else:
        x = np.atleast_2d(np.ones(imagestack.shape[0])).T

    if alignment[1]:
        y = np.atleast_2d(np.arange(minforce, maxforce, ystepforce))
        y = y[0][::-alignment[1]]
    else:
        y = np.atleast_2d(np.ones(imagestack.shape[1]))
    
    if any(alignment):
        potential = x * y
        print 'potential.shape = '
        print potential.shape
        reference = np.copy(imagestack[:,:,0])
    else:
        reference = np.copy(imagestack[:,:,0])
        potential = x * y
        

# run over all including reference to apply the forcing evenly, repeated runs may continue to shift the image!
    for i in range(imagestack.shape[2]):
        print 'aligning 0 with %s' %i
        
        forcedalign = np.copy(imagestack[:,:,i]) * potential

        (forcedalign,ishift) = single_correlation_align(potential * reference, forcedalign)
        nd.shift(imagestack[:,:,i],ishift,output = imagestack[:,:,i])
        shift.append(ishift)                                  

# plot residue to reference
#        imagestack[:,:,i] = reference - imagestack[:,:,i] 

#        imagestack[:,:,i] = reference
        

    return imagestack, shift

def single_correlation_align(reference, imagestack):
    'see crosscorrelation before stacks were cool'

    correlation = nd.correlate(imagestack, reference, mode = 'constant')
    maxcorrelation = correlation.argmax()
    centerref = np.array([reference.shape[0]/2,reference.shape[1]/2])

    # print "maxcorrelation = %s" %maxcorrelation 

    # print "centerref = " 
    # print centerref 

    shift = centerref - np.array(np.unravel_index(maxcorrelation,correlation.shape)) 

    nd.shift(imagestack,shift, output = imagestack)

    return (imagestack, shift)
#    return (correlation, shift)


def mask_align(imagestack, threshold = 5, alignment = (0,0)):
    'masks the aling array by thresholding.\n Aligns to the alighnment = (1,1) = top - left/n(-1,1) = btm - left/n(1,-1) = top - right/n(-1,-1) = bottom - right corner. A value of 0 in alignment does not align that direction.\n Returns the imagestack array aligned to the first array in the stack and a list of the shift (r[0]-a[0],r[1]-a[1]).'

    
    maskreference = np.where(imagestack[:,:,0] > threshold, 1, 0)
    
    shift = [(0,0)]
    drefcols  = 0

# count 0s for reference 
    if alignment[0]:
        refcols   = maskreference.sum(1)[::alignment[0]]
        i = 0
        while not refcols[i]:        
            drefcols += 1
            i    += 1
    drefrows = 0
    if alignment[1]:
        refrows   = maskreference.sum(0)[::alignment[1]]   
        i        = 0
        while not refrows[i]:        
            drefrows += 1
            i        += 1

    for k in range(1,imagestack.shape[2]):
        kshift = [0,0]
        maskalign     = np.where(imagestack[:,:,k] > threshold, 1, 0)
        if alignment[0]:
            aligncols = maskalign.sum(1)[::alignment[0]]
            dcols  = 0
            i = 0
            while not aligncols[i]:        
                dcols += 1
                i    += 1
            kshift[0] = dcols - drefcols
        if alignment[1]:
            alignrows = maskalign.sum(0)[::alignment[1]]
            drows  = 0
            i = 0
            while not alignrows[i]:        
                drows += 1
                i    += 1
                kshift[0] = drows - drefrows

        shift.append(kshift)
        imagestack[:,:,k] = nd.shift(imagestack[:,:,k],shift[k])

    return (imagestack, shift)


# def sift_align(imagestack, threshold = None):
#     'uses the silx.image.sift alignment. Returns aligned array and tupel  (r[0]-a[0],r[1]-a[1]). The optional threshold has not been shown to help for single wire images.'

# # initialize sift according to mail from Pierre Paleo

#     reference = np.ascontiguousarray(np.where(imagestack[:,:,0] > threshold, imagestack[:,:,0], 0))

#     alignplan = sift.LinearAlign(reference, devicetype="GPU")
# # alternative:
# #    alignplan = sift.LinearAlign(reference, device=(2,0))
    
#     shift = [(0,0)]
#     for i in range(1,imagestack.shape[2]):
        
#         dummy = np.copy(imagestack[:,:,i])
#         dummy = np.where(dummy > threshold, dummy, 0)

#         result  = alignplan.imagestack(dummy, shift_only = True, return_all=True)
#         if result:
#             shift.append(np.round(np.asarray(result['offset'],dtype = float)))
#         else:
#             shift.append(np.zeros(shape=2))

#         imagestack[:,:,i] = nd.shift(imagestack[:,:,i],shift[i])



#     return (imagestack, shift)

def shift_image(data, shift):
    for i, ishift in enumerate(shift):
        nd.shift(data[:,:,i], ishift, output = data[:,:,i],)
    
    return data

def real_from_rel(frame,data,shift = [1,1]):
    'this function gives you the real frame number if you give it the shifted frame number, an examplary dataset and the shift.\n returns -1 if the frame is out of the FOV.\n accepts slices'

    shift[0] = -shift[0]
    shift[1] = -shift[1]
    
    frames = np.arange(data.size)
    print frames
#    print shift
    frames = frames.reshape(data.shape)
    print frames
    frames = nd.shift(frames,shift,cval = -1)
    print frames
    frames = frames.flatten()
    print frames[frame]
    
    return frames[frame]

def image_align(imagestack, mode = {'mode':'sift'}):
    'returns the imagestack array stack aligned to the r = reference = imagestack[:,:,0] in it. The relative shift ist areturned as a list of touples (r[0]-a[0],r[1]-a[1])'

    # if mode['mode'] == 'sift':
    #     (imagestack, shift) = sift_align(imagestack, threshold = mode['threshold'])
    if mode['mode'] == 'mask':
        (imagestack, shift) = mask_align(imagestack, threshold = mode['threshold'], alignment = mode['alignment'])
    elif mode['mode'] == 'crosscorrelation':
        (imagestack, shift) = crosscorrelation_align(imagestack, alignment = mode['alignment'])
    elif mode['mode'] == 'forcedcrosscorrelation':
        (imagestack, shift) = forcedcrosscorrelation_align(imagestack, alignment = mode['alignment'])
    else:
        print "%s is not a valid mode" % mode    
        
    return (imagestack, shift)



def find_COR(imagestack, mode='elastix'):
    '''
    imagestack.shape = [nimage, npixel1, npixel2], for now nimage = 2
    returns COR as CORpixel1, CORpixel2, Rotationangel in deg
    '''
    raise NotImplementedError('TODO')
    
    return COR

def do_test():
    '''testfuction'''


    # local imports
    path_list = os.path.dirname(__file__).split(os.path.sep)
    importpath_list = []
    if 'skript' in path_list:
        for folder in pathlist:
            importpath_list.append(folder)
            if folder = 'skript':
                break
    importpath = os.path.sep.join(importpath_list)
    sys.path.append(importpath)        
    import pythonmisc.simplecalc.plot_array as plot_array
    
    # setup arrays to test alignment


    x         = np.atleast_2d(np.arange(100))
    y         = np.atleast_2d(np.arange(100)).T
    shift     = (5,15)
    reference = ((x-50)/100)**2 * ((y-50)/100)**2
    reference[50:55,50:55] = 50000
    imagestack1    = nd.shift(reference,shift)
    imagestack2    = nd.shift(imagestack1,shift)
    imagestack     = np.dstack([reference, imagestack1, imagestack2])
    print 'set up test data with shift = '
    print ((0,0),(shift[0],shift[1]),(shift[0]*2,shift[1]*2))
    print
    
    plot_arrays(imagestack)
    
    #    timing:
    # start_time = timeit.default_timer()
    # (dummy, (foundshift)) = image_align(dummy, mode = {'mode':'sift'})
    # print 'sift shift found:'
    # print foundshift
    # print 'took %s' % (timeit.default_timer() - start_time)
    # dummy     = np.copy(imagestack)


    ### testing maskshift
    start_time = timeit.default_timer()
    dummy     = np.copy(imagestack)
    mode = {'mode':'mask','threshold':np.percentile(imagestack,70),'alignment':(1,1)}
    (dummy, (foundshift)) = image_align(dummy, mode = mode)
    print '%s shift found:' %mode['mode']
    print foundshift
    print 'with alignment'
    print mode['alignment']
    print 'took %s' % (timeit.default_timer() - start_time)

    ### testing forcedcorrelation
    dummy     = np.copy(imagestack)
    start_time = timeit.default_timer()
    mode = {'mode':'forcedcrosscorrelation','alignment':(1,1)}
    (dummy, (foundshift)) = image_align(dummy, mode = mode)
    print '%s shift found:' %mode['mode']
    print 'with alignment'
    print mode['alignment']
    print foundshift
    print 'took %s' % (timeit.default_timer() - start_time)


    
   
if __name__ == '__main__':

    do_test()
    
    
